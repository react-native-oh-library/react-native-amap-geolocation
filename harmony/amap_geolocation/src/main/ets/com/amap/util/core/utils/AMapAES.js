import cryptoFramework from '@ohos.security.cryptoFramework'; import { LogUtil } from './LogUtil'; const a10 = '[AESEncryptUtil]'; export class r22 { constructor(algName = 'AES256') { this.algName = algName; } g22() { let z23 = new Uint8Array(r22.h22); let a24 = { data: z23 }; let b24 = { iv: a24, algName: 'IvParamsSpec' }; return b24; } i22() { let v23 = cryptoFramework.createSymKeyGenerator(this.algName); let w23 = v23.generateSymKey(); return w23.then(key => { this.j22 = key; return Promise.resolve(); }).catch(() => { return Promise.resolve(); }); } k22() { let s23 = this.g22(); let t23 = 'AES128|CBC|PKCS7'; this.l22 = cryptoFramework.createCipher(t23); if (this.j22 !== undefined) { let mode = cryptoFramework.CryptoMode.ENCRYPT_MODE; return this.l22.init(mode, this.j22, s23); } else { const u23 = `createAesCipher this.aesSymKey === undefined`; throw new Error(u23); } } n22() { let p23 = this.g22(); let q23 = 'AES128|CBC|PKCS7'; this.o22 = cryptoFramework.createCipher(q23); if (this.j22 !== undefined) { let mode = cryptoFramework.CryptoMode.DECRYPT_MODE; return this.o22.init(mode, this.j22, p23); } else { const r23 = `createAesDeCipher this.aesSymKey === undefined`; throw new Error(r23); } } encrypt(n23) { if (this.l22 !== undefined) { let plainText = { data: n23 }; return this.l22.doFinal(plainText); } else { const o23 = `encrypt this.aesCipher === undefined`; throw new Error(o23); } } decrypt(k23) { if (this.o22 !== undefined) { let m23 = { data: k23 }; return this.o22.doFinal(m23); } else { const l23 = `encrypt this.aesDeCipher === undefined`; throw new Error(l23); } } } r22.h22 = [17, 32, 107, -114, -18, -61, 39, 59, -6, 113, 122, 88, 11, 19, 90, -27]; function g22(iv) { let h23 = iv; let i23 = { data: h23 }; let j23 = { iv: i23, algName: 'IvParamsSpec' }; return j23; } export function p22(g23) { return { data: g23 }; } export function q22(s22, iv, data, t22, u22 = 'AES128|CBC|PKCS7') { let v22 = 'AES128'; let w22 = cryptoFramework.createSymKeyGenerator(v22); let x22; let y22 = p22(s22); let z22 = w22.convertKey(y22); return z22.then(key => { let f23 = g22(iv); x22 = cryptoFramework.createCipher(u22); let mode = t22; return x22.init(mode, key, f23); }).then(() => { let e23 = { data: data }; return x22.doFinal(e23); }).then(data => { return data.data; }).catch((error) => { LogUtil.e(a10, '', `catch error, ${error.code}, ${error.message}`); return Promise.reject(); }); } 