import util from '@ohos.util'; import { Utils } from './Utils'; const q32 = 0; const r32 = "US-ASCII"; const s32 = 2; const t32 = 1; const u32 = 8; const v32 = 76; const NEW_LINE = 10; const w32 = 32; const x32 = 16; const y32 = new Uint8Array([ 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 95 ]); const z32 = new Uint8Array([ 45, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 95, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122 ]); const a33 = new Uint8Array([ 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47 ]); const b33 = 61; export class Base64Util { static p28(data) { let e35 = Utils.f17(data); return Base64Util.b17(e35); } static b17(source) { if (source === undefined) { return ''; } let c35 = null; try { c35 = Base64Util.q28(source, 0, source.length, q32); } catch (d35) { } return c35; } static q28(source, off, len, options) { const b35 = Base64Util.r28(source, off, len, options); try { let decode = new util.TextDecoder(r32); return decode.decodeWithStream(b35); } catch (error) { return new util.TextDecoder().decodeWithStream(b35); } } static r28(source, off, len, options) { if (source == null) { throw new Error("Cannot serialize a null array."); } if (off < 0) { throw new Error("Cannot have negative offset: " + off); } if (len < 0) { throw new Error("Cannot have length offset: " + len); } if (off + len > source.length) { throw new Error(`Cannot have offset of ${off} and length of ${len} with array of length ${source.length}`); } if ((options & s32) !== 0) { const y34 = new c33(); const z34 = new d33(y34, t32 | options); const a35 = new e33(z34, options); a35.write(source.subarray(off, off + len)); a35.close(); return y34.s28(); } else { const s34 = (options & u32) !== 0; let t34 = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0); if (s34) { t34 += t34 / v32; } const u34 = new Uint8Array(t34); let d = 0; let e = 0; const v34 = len - 2; let w34 = 0; while (d < v34) { Base64Util.t28(source, d + off, 3, u34, e, options); w34 += 4; if (s34 && w34 >= v32) { u34[e + 4] = NEW_LINE; e++; w34 = 0; } d += 3; e += 4; } if (d < len) { Base64Util.t28(source, d + off, len - d, u34, e, options); e += 4; } if (e <= u34.length - 1) { const x34 = new Uint8Array(e); x34.set(u34.subarray(0, e)); return x34; } else { return u34; } } } static t28(source, n34, o34, destination, p34, options) { const q34 = Base64Util.u28(options); let r34 = (o34 > 0 ? ((source[n34] << 24) >>> 8) : 0) | (o34 > 1 ? ((source[n34 + 1] << 24) >>> 16) : 0) | (o34 > 2 ? ((source[n34 + 2] << 24) >>> 24) : 0); switch (o34) { case 3: destination[p34] = q34[r34 >>> 18]; destination[p34 + 1] = q34[(r34 >>> 12) & 0x3f]; destination[p34 + 2] = q34[(r34 >>> 6) & 0x3f]; destination[p34 + 3] = q34[r34 & 0x3f]; return destination; case 2: destination[p34] = q34[r34 >>> 18]; destination[p34 + 1] = q34[(r34 >>> 12) & 0x3f]; destination[p34 + 2] = q34[(r34 >>> 6) & 0x3f]; destination[p34 + 3] = b33; return destination; case 1: destination[p34] = q34[r34 >>> 18]; destination[p34 + 1] = q34[(r34 >>> 12) & 0x3f]; destination[p34 + 2] = b33; destination[p34 + 3] = b33; return destination; default: return destination; } } static u28(options) { if ((options & x32) === x32) { return y32; } else if ((options & w32) === w32) { return z32; } else { return a33; } } static k15(data) { if (data.length < 2) { return ""; } let m34 = Base64Util.d17(data.substring(1)); if (m34 !== undefined) { return m34; } else { return ""; } } static d17(data) { let l34 = Base64Util.z24(data); if (l34 !== undefined) { return Utils.uint8ArrayToString(l34); } else { return ""; } } static g17() { for (let k34 = 0; k34 < 128; k34++) { Base64Util.v28[k34] = -1; } for (let j34 = 'A'.charCodeAt(0); j34 <= 'Z'.charCodeAt(0); j34++) { Base64Util.v28[j34] = j34 - 'A'.charCodeAt(0); } for (let i34 = 'a'.charCodeAt(0); i34 <= 'z'.charCodeAt(0); i34++) { Base64Util.v28[i34] = i34 - 'a'.charCodeAt(0) + 26; } for (let h34 = '0'.charCodeAt(0); h34 <= '9'.charCodeAt(0); h34++) { Base64Util.v28[h34] = h34 - '0'.charCodeAt(0) + 52; } Base64Util.v28['+'.charCodeAt(0)] = 62; Base64Util.v28['/'.charCodeAt(0)] = 63; } static h17(source) { if (source === null) { return new Uint8Array(0); } const data = Utils.f17(source); const len = data.length; const buf = new Uint8Array(len); let b34 = 0; let c34 = 0; let d34, e34, f34, g34; while (c34 < len) { do { d34 = Base64Util.v28[data[c34++]]; } while (c34 < len && d34 === -1); if (d34 === -1) { break; } do { e34 = Base64Util.v28[data[c34++]]; } while (c34 < len && e34 === -1); if (e34 === -1) { break; } buf[b34++] = (d34 << 2) | ((e34 & 0x30) >>> 4); do { if (c34 === len) { return buf.slice(0, b34); } f34 = data[c34++]; if (f34 === 61) { return buf.slice(0, b34); } f34 = Base64Util.v28[f34]; } while (c34 < len && f34 === -1); if (f34 === -1) { break; } buf[b34++] = ((e34 & 0x0f) << 4) | ((f34 & 0x3c) >>> 2); do { if (c34 === len) { return buf.slice(0, b34); } g34 = data[c34++]; if (g34 === 61) { return buf.slice(0, b34); } g34 = Base64Util.v28[g34]; } while (c34 < len && g34 === -1); if (g34 === -1) { break; } buf[b34++] = ((f34 & 0x03) << 6) | g34; } return buf.slice(0, b34); } static w28(data) { if (data.length < 2) { return undefined; } let a34 = Base64Util.z24(data.substring(1)); return a34; } static x28(z33, data, iv) { return new Uint8Array(); } static z24(string) { const m33 = [ 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 62, 99, 99, 99, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 99, 99, 99, 99, 99, 99, 99, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 99, 99, 99, 99, 99, 99, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 99, 99, 99, 99, 99 ]; const n33 = new util.TextEncoder().encodeInto(string); const o33 = n33.length; const p33 = new Uint8Array(n33.buffer); const q33 = (o33 / 4 + 1) * 3; const r33 = new Uint8Array(q33); const s33 = new Uint8Array(r33.buffer); let t33 = 0; let u33 = 0; const v33 = new Uint8Array(4); for (let x33 = 0; x33 < o33; x33++) { const y33 = m33[p33[x33] & 0x7F]; if (y33 !== 99) { v33[t33] = y33; if (t33 === 3) { s33[u33++] = (v33[0] << 2) | (v33[1] >> 4); s33[u33++] = (v33[1] << 4) | (v33[2] >> 2); s33[u33++] = (v33[2] << 6) | v33[3]; } t33 = (t33 + 1) % 4; } } if (t33 > 0) s33[u33] = (v33[0] << 2) | (v33[1] >> 4); if (t33 > 1) s33[++u33] = (v33[1] << 4) | (v33[2] >> 2); if (t33 > 2) u33++; const w33 = r33.slice(0, u33); return u33 ? w33 : undefined; } } Base64Util.v28 = new Uint8Array(128); class c33 { constructor() { this.buffer = new Uint8Array(32); this.count = 0; } write(k33) { if (this.count >= this.buffer.length) { const l33 = new Uint8Array(this.buffer.length * 2); l33.set(this.buffer); this.buffer = l33; } this.buffer[this.count++] = k33; } s28() { return this.buffer.subarray(0, this.count); } } class d33 { constructor(j33, options) { this.y28 = j33; this.options = options; } write(i33) { this.y28.write(i33); } close() { } } class e33 { constructor(h33, options) { this.z28 = h33; this.options = options; } write(f33) { for (let g33 = 0; g33 < f33.length; g33++) { this.z28.write(f33[g33]); } } close() { } } 